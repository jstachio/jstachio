<html>
<body>

<h1 class="overview">User Guide</h1>

<strong>
JStachio: A type-safe Java Mustache templating engine.
</strong>
<p>
<em>
Templates are compiled into readable Java source code and value bindings are statically checked using the
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.compiler/javax/annotation/processing/package-summary.html">Java Annotation processing framework</a>.
</em>
</p>

<h2 class="toc-title">Contents</h2>

<nav class="js-toc"></nav>

<div class="js-toc-content">

<h2 id="gettingstarted">Getting Started</h2>

Follow these steps:

<ol>
  <li><a href="#installation">Setup your build correctly</a></li>
  <li><a href="#java_code">See or copy Java Code example.</a></li>
  <li><a href="#mustache">Read about mustache syntax if you are not familiar with it.</a></li>
  <li><a href="#configuration">Explore configuring to make JStachio your way.</a></li>
</ol>

If you are using Spring it is probably easiest to <a href="#spring-example">see the example projects</a>
and or copy it.

<h2 id="use_cases">Use Cases</h2>

There are three main use cases that this 
<a href="https://en.wikipedia.org/wiki/Template_processor">templating engine</a> 
is designed around with the cross cutting feature of 
<a href="https://en.wikipedia.org/wiki/Type_safety">type safety</a> and performance:

<ol>
<li>Templating web applications for traditional SEO friendly HTML server side rendering.</li>
<li>Templating for code generating.</li>
<li>General purpose inline templating instead of using StringBuilder and or a more powerful 
    <a href="https://openjdk.org/jeps/430">JEP 430 aka stringtemplates (still in preview)</a></li>
</ol>

<h2 id="project_information">Project Information</h2>

<dl class="notes">
  <dt>Source Control</dt>
  <dd><a href="https://github.com/jstachio/jstachio">https://github.com/jstachio/jstachio</a></dd>
  <dt>Issues</dt>
  <dd><a href="https://github.com/jstachio/jstachio/issues">https://github.com/jstachio/jstachio/issues</a></dd>
  <dt>Community</dt>
  <dd><a href="https://github.com/jstachio/jstachio/discussions">https://github.com/jstachio/jstachio/discussions</a></dd>
  <dt>User Guide</dt>
  <dd>
    <a href="index.html">This document</a>
  </dd>
  <dt>Javadoc</dt>
  <dd>
    <a href="#all-modules-table">This document (modules listing at bottom)</a>
  </dd>
  <dt>Mustache Spec</dt>
  <dd><a href="https://github.com/mustache/spec/tree/v1.3.0">v1.3.0</a></dd>
  <dt>Mustache Manual</dt>
  <dd><a href="https://jgonggrijp.gitlab.io/wontache/mustache.5.html">https://github.com/mustache/spec/tree/v1.3.0</a></dd>
</dl>

The project follows <a href="https://semver.org/">semantic versioning</a>.

<h3 id="requirements">Requirements</h3>

<ol>
  <li><a href="https://docs.oracle.com/en/java/javase/17/">Java 17 or greater</a></li>
  <li>A build system that supports running the Java compiler annotation processor</li>
</ol>

The only module needed during runtime is  
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/module-summary.html">
  <code>java.base</code>
</a>

<h3 id="limitations">Limitations</h3>

<h4 id="limitations_dynamic_templates">Dynamic Templates</h4>

<p>
Because mustache templates need to be analyzed at compile time JStachio does not
support dynamic templates. Dynamic meaning that the template markup cannot be changed
(e.g. concatenating a string to be used as a template)
at runtime without calling the Java compiler (which would generally be a bad idea for hosted platforms). 
<em>
Consequently JStachio is generally (ignoring extensions) is not a good fit for user
created templates (e.g. templates coming from a database).
</em>
</p>
<p>
However JStachio has very good <strong>{@linkplain io.jstach.jstache.JStacheLambda lambda section}</strong> 
support that can largely reproduce a lot of dynamic functionality. Furthermore 
a custom {@linkplain io.jstach.jstache.JStacheLambda lambda}  could be made to render dynamically constructed
templates using a reflection based
mustach engine such as <a href="https://github.com/samskivert/jmustache">JMustache</a>
for the places where that is needed.

<h4 id="limitations_reactive">Not Reactive</h4>

<p>
JStachio does not generate reactive code nor can handle reactive data types. 
Instead it generates code that writes to an {@link java.lang.Appendable}.
</p>

<p>
The current best workaround is <a href="#faq_reactive">to buffer as discussed in the FAQ</a>.
</p>

<p>
Its important to understand that "reactive" does not guarantee better performance
particularly in regards to template engines. There are only handful of templating
engines that handle backpressure as well as reactive data types and from benchmarking
they appear to be slower than JStachio writing to a buffer.
Furthermore if the model does not have reactive datatypes for its iterables
(e.g. {@link java.util.concurrent.Flow.Publisher}) it is unlikely to perform better
as the model is already in memory.
</p>

<h2 id="mustache">Mustache Syntax</h2>

The format of the templates should by default be <a href="https://mustache.github.io/">Mustache</a>
specifically <a href="https://github.com/mustache/spec/tree/v1.3.0">v1.3.0 syntax</a> . The syntax is informally
explained by the
<strong>
<a href="https://jgonggrijp.gitlab.io/wontache/mustache.5.html"><em>latest</em> mustache manual</a>
</strong> 
and
formally explained by the <a href="https://github.com/mustache/spec">spec</a>. 
<p>
<strong>N.B.</strong><em> currently 
<a href="https://jgonggrijp.gitlab.io/wontache/mustache.5.html">
    "https://jgonggrijp.gitlab.io/wontache/mustache.5.html"
</a> is the latest manual and <strong>NOT</strong>
"https://mustache.github.io/mustache.5.html".
</em>
</p>
<p>
There are some subtle differences in JStachio version of Mustache due to the static nature notably
how <code>Map&lt;String, ?&gt;</code> is handled. The contents of a <code>Map</code> are 
checked last even if it is a directly on the top of the context stack.
</p>
<p>
<strong>Most of the documentation of what mustache spec options are implemented and how
are discussed in the &#64;{@link io.jstach.jstache.JStache} annotation.</strong>
</p>
<h3 id="mustache_ws">Whitespace handling</h3>
<p>
One of the most important characteristics and spec compliance of modern Mustache (v1.3) 
is whitespace handling which unfortunately is not discussed much even in the current manual.
JStachio aims to follow the whitespace handling of the Mustache spec.
</p>
<p>
A general rule of this whitespace handling is a concept called "standalone" section-like tags.
When a single tag (a tag being everything but a variable and raw content) is on a line with only whitespace 
and a following newline when rendering the whitespace, tag, and newline are removed.
</p>

For the following example let us assue <code>sections</code> is a boolean that is <code>true</code>:

<pre><code class="language-hbs">
    {{#sections}}
    1
    {{/sections}}
    {{#sections}}
    2
    {{/sections}}
</code></pre>

The result will be: 

<pre><code class="language-plaintext">
    1
    2
</code></pre>

<p>
Furthermore if a parent or partial tag(s) are standalone the amount of whitespace (other than newline) preceding
them is used as indentation for the included template.
</p>

<h2 id="java_code">Java Code</h2>

Simply annotate a class with <strong>{@link io.jstach.jstache.JStache}</strong> like
below:

<pre><code class="language-java">
/*
 * Annotate the root model with an inline mustache template
 */
&#64;JStache(template = &quot;&quot;&quot;
        {{#people}}
        {{message}} {{name}}! You are {{#ageInfo}}{{age}}{{/ageInfo}} years old!
        {{#-last}}
        That is all for now!
        {{/-last}}
        {{/people}}
        &quot;&quot;&quot;)
public record HelloWorld(String message, List&lt;Person&gt; people) implements AgeLambdaSupport {}

public record Person(String name, LocalDate birthday) {}

public record AgeInfo(long age, String date) {}

public interface AgeLambdaSupport {
    &#64;JStacheLambda
    default AgeInfo ageInfo(Person person) {
        long age = ChronoUnit.YEARS.between(person.birthday(), LocalDate.now());
        String date = person.birthday().format(DateTimeFormatter.ISO_DATE);
        return new AgeInfo(age, date);
    }
}
</code></pre>

The above will generate a <code>HelloWorldRenderer</code> class from the inline template.
JStachio also supports external templates as well.
<p>
While you may use the generated classes directly to render HelloWorld instances in some cases it is
easier and better to use <strong>{@link io.jstach.jstachio.JStachio}</strong> 
to render directly from the model without referencing generated code.
</p>
Below is an example of that:

<pre><code class="language-java">
&#64;Test
public void testPerson() throws Exception {
    Person rick = new Person(&quot;Rick&quot;, LocalDate.now().minusYears(70));
    Person morty = new Person(&quot;Morty&quot;, LocalDate.now().minusYears(14));
    Person beth = new Person(&quot;Beth&quot;, LocalDate.now().minusYears(35));
    Person jerry = new Person(&quot;Jerry&quot;, LocalDate.now().minusYears(35));
    var hello = new HelloWorld(&quot;Hello alien&quot;, List.of(rick, morty, beth, jerry));
    // render without reflective lookup
    String actual = HelloWorldRenderer.of().execute(hello);
    // or use JStachio reflective lookup which will also apply filters and other advise
    actual = JStachio.render(hello);
    String expected = &quot;&quot;&quot;
            Hello alien Rick! You are 70 years old!
            Hello alien Morty! You are 14 years old!
            Hello alien Beth! You are 35 years old!
            Hello alien Jerry! You are 35 years old!
            That is all for now!
                            &quot;&quot;&quot;;
    assertEquals(expected, actual);

}
</code></pre>

<h3 id="jstachio_modules">Modules</h3>

JStachio is fully modularized consequently it is has many jars. The <a href="#all-modules-table">listing
  of modules</a> at the end of the guide explain what each module does as well as its 
<a href="https://maven.apache.org/pom.html#maven-coordinates">Maven GAV</a>. 
<p>
If your application or library is modularized (<code>module-info.java</code>)
and you would like to use the runtime module or extensions
there are some additional steps that maybe needed due to encapsulation requirements.
In some cases the easiest solution is to allow the jstachio runtime module reflective
access to the packages containing JStache models. Other solutions are discussed
on the {@link io.jstach.jstache.JStacheCatalog} annotation.
</p>
  
<h3 id="code_generation_mode">Code Generation Modes</h3>

JStachio provides two major modes for how code is generated.

<ol>
<li>JStachio enchanced mode: {@link io.jstach.jstache.JStacheType#JSTACHIO} </li>
<li>Zero dependency mode: {@link io.jstach.jstache.JStacheType#STACHE} </li>
</ol>

If you do not care about dependencies or footprint 
{@link io.jstach.jstache.JStacheType#JSTACHIO} is the preferred mode and is the default.

<p>

On the other hand {@linkplain io.jstach.jstache.JStacheType#STACHE Zero dependency mode} will generate
code that will only have references to itself and the JDK base module (java.base).
This is often desirable if you want to use JStachio for a code generation library 
(e.g. another annotation processor).  

<h2 id="how_it_works">How it works</h2>

When the compiler compiles your annotated code JStachio's annotation processor will run.
An annotation processor has access to the symbolic tree of the source code being compiled.
The classes that are annotated with JStachio's annotations are analyzed to find a template
and various other configuration. Once the template is found it is parsed while referring
to the symbolic tree of the class annotated with JStache (the model). 
From that it deduces how to generate Java code that will navigate the model 
and output text based on the template.

<p>
    More explanation is available on {@link io.jstach.jstache.JStache} javadoc.
</p>



<h2 id="installation">Installation</h2>

JStachio uses the Java annotation processor facility to generate code.
You will need to set that up otherwise code will not be generated.



<h3 id="maven">Maven</h3>

Maven configuration has two choices. <code>annotationProcessorPaths</code> or classpath.

<h4 id="maven_annotationProcessorPaths">Option 1 annotationProcessorPaths</h4>
<pre class="language-xml">
{@code
<properties>
    <io.jstach.version>_VERSION_</io.jstach.version>
</properties>
...
<dependencies>
    <dependency>
        <groupId>io.jstach</groupId>
        <artifactId>jstachio</artifactId>
        <version>${io.jstach.version}</version>
    </dependency>
</dependencies>
...
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.8.1</version>
            <configuration>
                <source>17</source> <!-- 17 is the minimum -->
                <target>17</target> <!-- 17 is the minimum -->
                
                <!-- You may not need annotationProcessorPaths if jstachio-apt is added as an option dep -->
                <annotationProcessorPaths>
                    <path>
                        <groupId>io.jstach</groupId>
                        <artifactId>jstachio-apt</artifactId>
                        <version>${io.jstach.version}</version>
                    </path>
                    <!-- other annotation processors -->
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>
}
</pre>

<h4 id="maven_classpath">Option 2 classpath</h4>

JStachio annotation processor <em>MAY</em> also work without being registered in <code>annotationProcessorPaths</code>
even for modular libraries and applications provided there is not already an <code>annotationProcessorPaths</code>
set. This can be desirable as it allows less explicit maven configuration and normal dependency management
(as wells avoids this bug: <a href="https://issues.apache.org/jira/browse/MCOMPILER-391">MCOMPILER-391</a>).

<p>

To make it work you would add <code>jstachio-apt</code> as an optional and provided dependency:

<pre class="language-xml">
{@code
<dependencies>
    <dependency>
        <groupId>io.jstach</groupId>
        <artifactId>jstachio-apt</artifactId>
        <version>${io.jstach.version}</version>
        <optional>true</optional>
        <scope>provided</scope>
    </dependency>
<dependencies>
}
</pre>

This works because maven will put <code>jstachio-apt</code> on the classpath instead of the module path during compilation
provided you <strong>DO NOT put</strong> <code>requires io.jstach.apt</code> in your <code>module-info.java</code>
which you should never do in general.
<p>
Be aware that the above option may have problems if you have multiple annotation processors 
as some processors rely on specific order.

<em>(note you still need to add either io.jstach:jstache or io.jstach:jstachio as a dependency.)</em>


<h4 id="maven_zerodep">Maven Zero dependency configuration</h4>

If all of your JStache are configured for zero dependency via  <code>JStacheConfig.type() == STACHE</code>
you can instead rely on only one compile time dependency (replace dependencies section with following):

<pre class="language-xml">
{@code
<dependencies>
    <dependency>
        <groupId>io.jstach</groupId>
        <artifactId>jstachio-annotation</artifactId>
        <version>${io.jstach.version}</version>
        <optional>true</optional>
        <scope>provided</scope>
    </dependency>
<dependencies>
}
</pre>

<h3 id="3.2">Gradle</h3>

<pre><code class="language-kotlin">
dependencies {
    
    implementation 'io.jstach:jstachio:_VERSION_'
 
    annotationProcessor 'io.jstach:jstachio-apt:_VERSION_'
}
</code>
</pre>

<h4 id="gradle_zerodep">Gradle Zero dependency configuration</h4>

If all of your JStache are configured for zero dependency via  <code>JStacheConfig.type() == STACHE</code>
you can instead configure Gradle like:

<pre><code class="language-kotlin">
dependencies {
    
    compileOnly 'io.jstach:jstachio-annotation:_VERSION_'
 
    annotationProcessor 'io.jstach:jstachio-apt:_VERSION_'
}
</code>
</pre>

<h2 id="configuration">Configuration</h2>

<h3 id="compile_config">Compile time Configuration</h3>

{@link io.jstach.jstache.JStache}, {@link io.jstach.jstache.JStacheConfig},
and {@link io.jstach.jstache.JStacheFlags}
are heavily documented on static configuration of JStachio via annotations
as well as in some cases compiler command line arguments.
<p>
JStachio static config allows you to configure:
</p>

<ol>
  <li>Where {@linkplain io.jstach.jstache.JStacheConfig#pathing() external templates are stored} and referred.</li>
  <li>How code is generated including what {@linkplain io.jstach.jstache.JStacheInterfaces interfaces or classes are extended}</li>
  <li>What {@linkplain io.jstach.jstache.JStacheFormatterTypes types are allowed to be outputted without compiler error}</li>
  <li>How types are {@linkplain io.jstach.jstachio.Formatter formatted}</li>
  <li>{@linkplain io.jstach.jstachio.Escaper Escaping}</li>
  <li>{@linkplain io.jstach.jstache.JStacheFlags.Flag#NO_NULL_CHECKING Null checking}</li>
  <li>... and much more</li>
</ol>

<p>
The most notable configuration is that you can configure whether or not zero dependency
code is generated via {@link io.jstach.jstache.JStacheConfig#type()} as well as 
location paths of template files via {@link io.jstach.jstache.JStachePath} 
and what interfaces generated code extends via {@link io.jstach.jstache.JStacheInterfaces}. 
</p>

<h3 id="runtime_config">Runtime Configuration</h3>

Certain configuration such as logging and whether or not to use
reflection is only avaiable during runtime when using the
JStachio runtime module and the default JStachio. 
This is documented in {@link io.jstach.jstachio.spi.JStachioConfig}.

<h2 id="integration">Extensions and Integrations</h2>

Using the {@link io.jstach.jstachio.JStachio} {@link io.jstach.jstachio/  runtime module}
additional extensions are available. They are in the 
<a href="https://github.com/jstachio/jstachio/tree/main/opt"><code>opt</code></a> directory of the project.
<p>
Many extensions just require the extension jars be in the classpath and are loaded via
the ServiceLoader automatically (unless disabled or using DI framework).
</p>

<h3 id="jmustache">JMustache</h3>
<strong>See {@link io.jstach.opt.jmustache/ } and {@link io.jstach.opt.jmustache.JMustacheRenderer}</strong>
<p>
The most notable extension is the {@link io.jstach.opt.jmustache/ JMustache extension} as it 
allows you to change templates without recompiling the application.
</p>
One major caveat is that JMustache currently does not support template inheritance 
(aka parents and blocks) so if your jstachio templates use template inheritance JMustache 
will probably not work.

<h3 id="springframework">Spring Framework</h3>
<strong>See {@link io.jstach.opt.spring/ }</strong>
<p>
JStachio normally uses the {@link java.util.ServiceLoader} for loading runtime components. 
This extension will use Spring DI to find components as well as provides integration with Spring Web.
</p>

<h4 id="spring-web">Spring Web support</h4>

<strong>See {@link io.jstach.opt.spring.web.JStachioHttpMessageConverter}</strong>
<p>
For Spring MVC the integration allows you to return models and they will automatically
be rendered to the response.
</p>

<pre><code class="language-java">
    &#64;JStache
    public record HelloModel(String message){}
    
    &#64;GetMapping(value = "/")
    &#64;ResponseBody
    public HelloModel hello() {
        return new HelloModel("Spring Boot is now JStachioed!");
    }
</code></pre>

 <h4 id="spring-webmvc">Web MVC integration</h4>
 <strong>See {@link io.jstach.opt.spring.webmvc}</strong>
 <p>
 {@link io.jstach.opt.spring.webmvc.JStachioModelView} allows you to construct
 servlet based Spring Views for traditional Web MVC Spring applications.
 This integration is tied to the servlet API and thus will need it as
 a dependency.
 
 <h4 id="spring-webflux">Web Flux integration</h4>
 <strong>See {@link io.jstach.opt.spring.webflux}</strong>
 <p>
 {@link io.jstach.opt.spring.webflux.JStachioEncoder} allows
 reactive containers such as Flux/Mono to contain JStache models.

<h4 id="spring-example">Spring Web MVC Example Application</h4>
<strong>See {@link io.jstach.opt.spring.example/ } module and <a href="https://github.com/jstachio/jstachio/tree/main/opt/jstachio-spring-example">github project</a></strong>
<p>
There is an example modularized {@link io.jstach.opt.spring.example/ Spring Boot Web MVC application}.
While the code is Javadoc and the source is linked (if you click on the classes the source code is shown) 
it might be easier to look 
<strong><a href="https://github.com/jstachio/jstachio/tree/main/opt/jstachio-spring-example">directly on github (link to project).</a></strong> 


<h4 id="spring-webflux-example">Spring Webflux Example Application</h4>
<strong>See {@link io.jstach.opt.spring.webflux.example/ } module and <a href="https://github.com/jstachio/jstachio/tree/main/opt/jstachio-spring-webflux-example">github project</a></strong>
<p>
There is an example modularized {@link io.jstach.opt.spring.webflux.example/ Spring Boot Webflux reative application}.
While the code is Javadoc and the source is linked (if you click on the classes the source code is shown) 
it might be easier to look 
<strong><a href="https://github.com/jstachio/jstachio/tree/main/opt/jstachio-spring-example">directly on github (link to project).</a></strong> 


<h2 id="FAQ">FAQ</h2>

<h3 id="faq_template_not_found">Why can't JStachio find my templates?</h3>

There are many problems that can happen but usually it boils down to three issues:

<ol>
  <li>The annotation processor did not run.</li>
  <li>The annotation processor did run but cannot find external template resources.</li>
  <li>The runtime cannot reflectively find a template for a model.</li>
</ol>

<p>
The first thing to check is to make sure the template classes are being generated.
Usually the generated classes after build will reside in 
<code>target/generated-sources/annotations</code>.
</p>
<p>
If compilation is failing because the annotation processor cannot find your templates
make sure that the external templates (mustache files) are put in 
<code>src/main/resources</code>. It is not recommended and generally will not work
if you put template resources in <code>src/main/java</code>.
The above can be disregarded if the template is inlined (e.g. a string).
</p>
<p>
If the templates are generated but <code>JStachio.render</code> is not working
a reflection exception will be thrown. This may happen if the generated
class is not available because of incremental compiling and particularly
a problem with Maven. Try a full rebuild (e.g. mvn clean package).
</p>
<p>
If your application is a modular application (<code>module-info.java</code>)
then you will need to either allow reflective access to JStachio 
(e.g <code> open somepackage to io.jstach.jstachio</code>) or 
register a Service Located TemplateProvider. 
The solution is discussed in {@link io.jstach.jstache.JStacheCatalog} annotation.
</p>

<h3 id="faq_hard_behavior">How do I do XYZ complicated logic in my template?</h3>

Mustache is inherently simple and is called logicless for a reason.
If you need complicated behavior then it is recommended to put that behavior in
either a {@linkplain io.jstach.jstache.JStacheLambda lambda} or method call.
<p>
Because JStachio always requires an annotated class that serves as the model it can be argued 
that the model associated with the template is more of a view model
then a domain model (or DTO). Therefore it is recommended that you take advantage of that
top level class and add methods needed to help render.
</p>
If you have common logic you can use normal Java practices to share the logic such as interfaces
(default methods) or abstract classes and have the model implement or extend (respectively).
You can even enforce that models always implement an interface with 
{@link io.jstach.jstache.JStacheInterfaces}. 


<h3 id="faq_layout">How do I do layout?</h3>

Modern Mustache has the concept of 
<a href="https://jgonggrijp.gitlab.io/wontache/mustache.5.html#Parents">parent partials</a>
and <a href="https://jgonggrijp.gitlab.io/wontache/mustache.5.html#Blocks">blocks</a> that
is often called template inheritance. JStachio supports this.

<p>
Below is an example:
</p>

<code>layout.mustache</code>

<pre>
<code class="language-hbs">
{{! layout.mustache }}
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{$title}}My site{{/title}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  {{$body}}Replace Me{{/body}}
  &lt;/body&gt;
&lt;/html&gt;
</code>
</pre>

<code>page.mustache</code>

<pre>
<code class="language-handlebars">
{{! page.mustache }}
{{&lt; layout}}
  {{$title}}My Page!{{/title}}
  {{$body}}
  This is a page
  {{/body}}
{{/layout}}
</code>
</pre>


<h3 id="faq_hot_reload">I want to change templates without restarting my app. How do I do that?</h3> 

See the <a href="#jmustache">JMustache Extension</a> that uses reflection. In the future JStachio
will have its own reflection based runtime for template development but for now we are leveraging the
fact that JMustache is almost equivalent to JStachio once configured correctly.


<h3 id="faq_no_reflection">How do I make the JStachio runtime use zero reflection?</h3>

The JStachio runtime mainly provides a way to find a template based on a model. 
To do this it will try the ServiceLoader first and then regular reflection.
Thus to avoid this a list of model to templates needs to be registered.
<p>
<strong>See {@link io.jstach.jstache.JStacheCatalog}.</strong>
</p>

<h3 id="faq_map">My MVC library uses Map&lt;String,Object&gt; for models what should I do?</h3>

<p>
As mentioned throughout this doc JStachio is not ideal for <code>Map&lt;String,Object&gt;</code>.
</p>

<p>
If this is a greenfield project (ie starting from scratch) it is recommend that you have your controllers
return the model objects that are annotated with <code>&#64;{@link io.jstach.jstache.JStache}</code>
and wherever the framework does return type conversion or request body conversion you call
{@link io.jstach.jstachio.JStachio} render/execute functions. 
The {@link io.jstach.opt.spring/ spring integration} shows an example of this technique.
</p>

<p>
If your library only allows <code>Map&lt;String,Object&gt;</code> (or similar analog aka request attributes) 
or you have existing code you can make a special entry in the <code>Map&lt;String,Object&gt;</code> with
the model and then wherever normal template engines are executed you pull the entry out and call
{@link io.jstach.jstachio.JStachio} render/execute functions.
</p>

<p>
As for existing request attributes or entries in <code>Map&lt;String,Object&gt;</code> that you depend on you 
can simply have that as a field or method on your model object. When accessing those attributes it is
best to use dotted path notation.
</p>

<pre>
<code class="language-java">
&#64;JStache(template = "{{attributes.something}}")
public record Page(Map&lt;String, Object&gt; attributes){}

public Page someController(Map&lt;String,Object&gt; requestAttributes) {
  return new Page(requestAttributes);
}

</code>
</pre>

If you do not want repeatedly add the request attributes see 
<a href="#faq_decorate_model">FAQ on decorating model</a>. 

<p>
If you are still having trouble integrating <a href="#project_information">please file an issue</a>.
</p>

<h3 id="faq_di">I don't use Spring but some other Dependency Injection library how do I integrate?</h3> 

See {@link io.jstach.jstache.JStacheInterfaces} and {@link io.jstach.jstachio.spi}.

First start by looking at the Spring implementation: {@link io.jstach.opt.spring}.

Most dependency injection frameworks have a way to discover all classes of some type or have some annotation.
{@link io.jstach.jstache.JStacheInterfaces} allows you to generate Templates/Renderers that will have annotations
or implement an interface that you can use to discover the generated code. 
<p>
Once that is done you can then add the list of found templates by implementing your own JStachio by
implementing a {@link io.jstach.jstachio.spi.JStachioTemplateFinder} and then 
extending {@link io.jstach.jstachio.spi.AbstractJStachio} or using {@link io.jstach.jstachio.spi.JStachioFactory#builder()}.
</p>


<h3 id="faq_i18n">How do I do I18N and Localization?</h3>

There are a lot of techniques to handle internationalization (I18N).
JStachio currently does not ship with an opinionated way to handle it.
If you would like JStachio with one please comment or thumbs-up: 

<a href="https://github.com/jstachio/jstachio/issues/104">#104</a>.

<p>
Regardless there are three major techniques all with various pros and cons as well as can be mixed:
</p>

<ol>
  <li>Load the model with already translated messages</li>
  <li>Use JStachio Lambdas: {@link io.jstach.jstache.JStacheLambda}</li>
  <li>Use a partial for each locale</li>
</ol>

<p>
The first technique is one of the easiest and safest. Because JStachio always requires an annotated
class that serves as the model it can be argued that the model associated with the template is more of a view model
then a domain model (or DTO). Therefore view oriented helper methods can be added that can do the translation.
</p>

<p>
The second alternative is to use Lambdas. There is an unsupported example of doing that in JStachio's test code here:
<a href="https://github.com/jstachio/jstachio/tree/main/test/examples/src/main/java/io/jstach/examples/i18n">
  https://github.com/jstachio/jstachio/tree/main/test/examples/src/main/java/io/jstach/examples/i18n
</a>
</p>

<p>
The last technique works wells for dynamic mustache implementations like JMustache and mustache.java but not so well for
JStachio. To have a partial for each locale in JStachio would require writting section conditions
to determine the correct partial to load. This is because JStachio cannot dynamically load a template and
needs to analyze it at compile time. Even then every locale's template would need to be compiled. 
In the future JStachio may add better support for this but it is unlikely because it is still generally 
not recommended to handle i18n this way.
</p>

<h3 id="faq_decorate_model">How can I add cross cutting model attributes like CSRF?</h3>

A common problem in web development is needing model attributes that are pseudo global or request based.

In traditional MVC style web applications the model is usually a mutable <code>Map&lt;String,Object&gt;</code> so 
attributes like CSRF are added after the controller has filled the model but before rendering.

However this presents a problem to JStachio as JStachio prefers you do not use <code>Map&lt;String,Object&gt;</code>
as models (you can but not as a root model and you loose type safety).

There are two general strategies:

<ol>
  <li>Make the model mutable for those attributes and set the attributes by intercepting before rendering happens. (the push way)</li>
  <li>Use a Service Locator / Thread Local like pattern with an interface with pull method that all models get. (the pull way)</li>
</ol>

<p>
The Spring integration provides some guidance on doing the first strategy via 
{@link io.jstach.opt.spring.webmvc.JStachioModelViewConfigurer}.
</p>

<p>
The second technique is to make request information available through the callstack by usually using ThreadLocals
and then having an interface with a method that pulls the info from the ThreadLocal variable.
This is a more advance technique but does allow keeping your models immutable (e.g. using record).
</p>

<h3 id="faq_reactive">How do I integrate with reactive frameworks such as Reactor?</h3>

As noted in the limitations JStachio does not generate reactive code.
The short answer is to handle the backpressure by simply buffering.

<p>
For example a simple workaround it just to buffer the entire output and hand the output
as a String or ByteBuffer off to the reactive framework. The idea being that
memory is cheap and the model has to be fully loaded anyway since JStachio does
not support iterating over reactive data types.
</p>

<p>
Another workaround if the output can be large is to render in parts
and to compose those parts with reactive operators such as <code>flatMap</code> 
and <code>map</code>.

For example lets say we are generating a page with a list of rows. We would
first render a header as String and then reactively iterate over the rows rendering them to
String and then finally render a footer.
</p>

The <a href="#spring-webflux-example">Spring webflux example project</a> shows an example of 
using the buffering technique.


<h3 id="faq_nocode">Can I make JStachio only check mustache and not generate code?</h3> 

Currently no. But if you would like that please comment or thumbs-up:
<a href="https://github.com/jstachio/jstachio/issues/103">#103</a>


<h3 id="faq_whitespace">Can I make whitespace explicit instead of "standalone" rules?</h3> 

<p>
Currently no. <a href="#mustache_ws">JStachio follows the spec whitespace rules.</a> 
However in theory it is always possible to achieve all the same output that no whitespace handling does.
</p>

If you would like an option to disable JStachio whitespace handling like some mustache implementations
offer please file an issue.

<h3 id="faq_editdoc">There is a typo in this documentation how can I fix it?</h3>

If you would like to make corrections please
file an issue or even better fork, edit, PR this file: 
<pre><a href="https://github.com/jstachio/jstachio/blob/main/doc/src/main/javadoc/overview.html">doc/src/main/javadoc/overview.html</a></pre>

<h3 id="faq_javadoc">Where is the Javadoc?</h3>

<em>Shockingly this document is the Javadoc!</em> To be precise it is the aggregate javadoc 
<code>overview.html</code>. 

The modules javadocs should be at the bottom of this document and the search bar at the top can be
used to find documented classes.

<br/>
</div>

</body>
</html>
